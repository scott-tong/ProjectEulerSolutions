package projectEulerProblems;

/**
 * Calculates Largest Palindrome
 * @author Scott Tong
 *
 */
public class LargestPalindrome {
	/**
	 * returns the largest palindrome that can be generated by two numbers of a certain length
	 * ex: 9009 = 91 × 99.
	 * @param numSize
	 * @return
	 */
	public static int LargestPalindromeTwoNums(int numSize){
		/*if the number size is 1 then just return 9. I was lazy and just added 
		 * a line to detect if the user had put in a negative number size which
		 */
		if(numSize <= 1) {
			return 9;
		}
		
		/* generate every possible value of a given number size (this step is almost certainly
		 * inefficient but I was going for a speed of figuring out a solution)
		 */
		int biggestPalindrome = -1;
		int[] allVals = new int[(int)Math.pow(10,numSize)];
		int allValInd = 0;
		
		for(int i = (int)Math.pow(10,(numSize-1)); i < (int)Math.pow(10,numSize); i++) {
			allVals[allValInd] = i;
			allValInd++;
		}
		
		/* brute force solution
		 * Just multiply every number by every other and mark the biggest
		 */
		for(int i = 0; i < allVals.length; i++) {
			for(int q = 0; q < allVals.length; q++) {
				if(isPalindrome(i*q) && i*q > biggestPalindrome)
					biggestPalindrome = i*q;
			}
		}
		
		
		return biggestPalindrome;
	}
	
	private static boolean isPalindrome(int val) {
		String stringVal = ""+val;
//		for(int i = 0; i < stringVal.length()/2; i++) {
//			if(stringVal.charAt(i) != stringVal.charAt(stringVal.length()-1-i));
//				return false;
//		}
		
		int start = 0;
		int end = stringVal.length()-1;
		while(start <= end) {
			if(stringVal.charAt(start) != stringVal.charAt(end))
				return false;
			start++;
			end--;
		}
		
		return true;
	}
}
